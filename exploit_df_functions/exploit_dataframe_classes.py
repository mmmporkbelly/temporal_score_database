"""
These classes grab exploit code weight data from the following sources:
-ExploitDB
-Metasploit
-EPSS
-KEV
Thank you to t0sche for the inspiration:
https://github.com/t0sche/cvss-bt/blob/main/code/enrich_nvd.py
"""

import pandas as pd
import requests
import json
import gzip
import logging
from .get_retry import Retry
from datetime import date, timedelta
from io import BytesIO, StringIO
from re import findall
from os import path, makedirs


# Foundational class for exploit dataframes
class CVEDataFrame:

    # Store dataframe given as argument
    def __init__(self, df, data_date):
        if not df.empty:
            self._df = df
        else:
            raise FileNotFoundError(f"Dataframe is empty")
        self._data_date = data_date

    # Function to make get request - implements Retry from get_retry.py
    @staticmethod
    def get_request(url, headers=None, params=None):
        res = requests.get(url, headers=headers)
        res = Retry.check_for_retries(res, params, headers, url)
        if res.status_code == 200:
            logging.info("Received response from get request")
        return res

    # Function to return if date of dataframe is today
    def df_up_to_date(self):
        return date.today() == self._data_date

    # Function for querying if CVE exists in dataframe
    def query_for_cve(self, cve):
        try:
            result = self._df.query(f'cve == "{cve}"')
            if not result.empty:
                return result
            else:
                return False
        except Exception as e:
            raise FileNotFoundError(f"{e}: Cannot query")

    # Function to return df
    def all_df_data(self):
        return self._df

    # Function to return date of data
    def data_date(self):
        return self._data_date


class KevDataFrame(CVEDataFrame):

    # Query for KEV data upon init
    def __init__(self):

        try:
            # API call to get KEV list
            logging.info("Grabbing KEV Catalogue")
            url = "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json"
            headers = {"Content-Type": "application/json"}
            response = KevDataFrame.get_request(url, headers=headers)
            response = json.loads(response.text)
            # Parse through response
            kev_df = {'CVE_ID': [],
                      'on_kev': [],
                      'affiliatedwithransomware': []
                      }
            for cve in response['vulnerabilities']:
                kev_df['CVE_ID'].append(cve['cveID'])
                kev_df['on_kev'].append(True)
                ransomware_affiliation = cve['knownRansomwareCampaignUse']
                if ransomware_affiliation == 'Known':
                    kev_df['affiliatedwithransomware'].append(True)
                else:
                    kev_df['affiliatedwithransomware'].append(False)

        except Exception as e:
            logging.info(f"{e}: Failed to get KEV Catalogue")

        # Store DF
        try:
            kev_df = pd.DataFrame(kev_df)
        except Exception as e:
            raise RuntimeError(f"{e}: Cannot convert to dataframe")

        # Store date of query
        data_date = response['catalogVersion'].replace('.', '-')

        # Init the parent class
        super().__init__(kev_df, data_date)

    # Function to check ransomware status
    def ransomware_affiliation(self, cve):
        row = self.query_for_cve(cve)
        if not row.empty:
            return row['affiliatedwithransomware'].to_numpy()[0]
        else:
            return False


# EPSS Dataframe class
class EPSSDataFrame(CVEDataFrame):

    # Query for EPSS Data upon init
    def __init__(self):

        # API call to get complete EPSS csv
        try:
            # Make the call, decode bytes
            logging.info("Grabbing EPSS list from Cyentia")
            query_date = date.today()
            epss_request = requests.get(f'http://epss.cyentia.com/epss_scores-{query_date}.csv.gz').content
            epss_request = BytesIO(epss_request)
            # Convert to df
            epss_df = pd.read_csv(
                epss_request,
                compression='gzip',
                comment='#'
            )
            epss_df.rename(columns={'cve': 'CVE_ID', 'epss': 'EPSS',
                                    'percentile': 'EPSS_Percentile'}, inplace=True)
            epss_df['EPSS_Percentile'] = (epss_df['EPSS_Percentile'] * 100).apply(lambda x: f"{x:.2f}%")

        # If EPSS data from Cyentia is not ready for today, query for day before
        except gzip.BadGzipFile:
            # Make the call, decode bytes
            query_date = date.today() - timedelta(days=1)
            epss_request = CVEDataFrame.get_request(
                f'http://epss.cyentia.com/epss_scores-{query_date}.csv.gz').content

            # Convert to df
            epss_request = BytesIO(epss_request)
            epss_df = pd.read_csv(
                epss_request,
                compression='gzip',
                comment='#'
            )
            epss_df.rename(columns={'cve': 'CVE_ID', 'epss': 'EPSS',
                                        'percentile': 'EPSS_PERCENTILE'}, inplace=True)
            epss_df['EPSS_Percentile'] = (epss_df['EPSS_Percentile'] * 100).apply(lambda x: f"{x:.2f}%")

        except Exception as e:
            raise ProcessLookupError(f"{e}: Not able to query EPSS Catalogue")

        # init parent class
        logging.info(f"Retrieved EPSS data from {query_date}")
        super().__init__(epss_df, query_date)

    # Function to query EPSS, if not in EPSS return 0
    def epss_score(self, cve):
        row = self.query_for_cve(cve)
        if not row.empty:
            return row['epss'].to_numpy()[0]
        return None


# ExploitDB Dataframe class
class ExploitDBDataFrame(CVEDataFrame):

    # Query for EPSS data upon init
    def __init__(self):
        # Get csv from gitlab, alter csv row
        try:
            logging.info("Grabbing exploitDB CSV file")
            exploitdb_request = CVEDataFrame.get_request(
                'https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv'
            ).content
            exploitdb_request = BytesIO(exploitdb_request)
            exploitdb_df = pd.read_csv(
                exploitdb_request,
                usecols=['codes']
            )

            # Only grab codes column, rename as cve
            exploitdb_df = exploitdb_df.rename(columns={"codes": "cve"})

            # Drop duplicates, extract CVEs. Borrowed from t0sche (see description)
            exploitdb_df.drop_duplicates(inplace=True)
            exploitdb_df = exploitdb_df['cve'].str.extract(r"(CVE-\d{4}-\d{4,7})", expand=False).dropna().values
            exploitdb_df = pd.DataFrame(exploitdb_df, columns=['CVE_ID'])
            exploitdb_df['In_ExploitDB'] = True

        except Exception as e:
            raise ProcessLookupError(f"{e}: Not able to query ExploitDB Catalogue")

        # Set query date
        query_date = date.today()

        # init parent class
        super().__init__(exploitdb_df, query_date)


# Metasploit Dataframe class
class MetasploitDataFrame(CVEDataFrame):

    # Query for Metasploit data upon init
    def __init__(self):
        try:
            logging.info("Grabbing Metasploit module list")
            url = 'https://raw.githubusercontent.com/rapid7/metasploit-framework/master/db/modules_metadata_base.json'
            headers = {"Content-Type": "application/json"}
            response = CVEDataFrame.get_request(url, headers=headers)
            response = json.loads(response.text)
        except Exception as e:
            raise ProcessLookupError(f"{e}: Not able to query Metasploit list")

        # Format response, input to df. Thank you to t0sche again
        metasploit_list = []
        for item in response:
            if 'references' in response[item]:
                cve_references = [ref for ref in response[item]['references'] if ref.startswith('CVE-')]
                metasploit_list.extend(cve_references)
        metasploit_df = pd.DataFrame(metasploit_list, columns=['CVE_ID'])
        metasploit_df['Metasploit_Module'] = True

        # Set date, init parent class
        query_date = date.today()
        super().__init__(metasploit_df, query_date)


# GitHub Dataframe class
class GithubDataFrame(CVEDataFrame):

    # Query for GitHub data upon init
    def __init__(self):

        # Grab all CVEs in the trickest GitHub repo
        try:
            logging.info("Grabbing GitHub PoC list")
            url = 'https://api.github.com/repos/trickest/cve/git/trees/main?recursive=1'
            headers = {"Content-Type": "application/json"}
            response = CVEDataFrame.get_request(url, headers=headers)
            response = json.loads(response.text)
        except Exception as e:
            raise ProcessLookupError(f"{e}: Not able to query Github list")

        # Format response, input to df
        github_list = []
        for item in response['tree']:
            if item.get('path'):

                # Regex for CVE ID. If ID, add to GitHub list
                cve_id = findall(r'CVE-\d{4}-\d*', item['path'])
                if cve_id:
                    github_list.append(cve_id[0])

        # Convert to df
        github_df = pd.DataFrame(github_list, columns=['CVE_ID'])
        github_df['POC_In_Github'] = True

        # Set date, init parent class
        query_date = date.today()
        super().__init__(github_df, query_date)


# Nuclei Dataframe class
class NucleiDataFrame(CVEDataFrame):

    # Grab data from Nuclei. Thank you again t0sche
    def __init__(self):
        logging.info("Grabbing Nuclei CVE list")
        url = 'https://raw.githubusercontent.com/projectdiscovery/nuclei-templates/main/cves.json'
        headers = {"Content-Type": "application/json"}
        response = CVEDataFrame.get_request(url, headers=headers)
        response = response.text

        # Nuclei response formats each entry as its own dictionary. Just throw in the response as a df
        nuclei_df = pd.read_json(StringIO(response), lines=True)
        nuclei_df.rename(columns={"ID": "CVE_ID"}, inplace=True)
        nuclei_df = nuclei_df.drop(columns=['Info', 'file_path'])
        nuclei_df['On_Nuclei'] = True

        # Set date, init parent class
        query_date = date.today()
        super().__init__(nuclei_df, query_date)

